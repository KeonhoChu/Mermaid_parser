We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (maybe decision nodes?), summary.

We must map shapes: [] = "rect", {} = "diamond", () = "circle", (()) = "double_circle", [[]] = "double_rect", >> = "subroutine". In the diagram, nodes are defined with various brackets:

- START([Start]) => label "Start", shape rect (since []), id "START"? Actually node id is START. So shape rect.

- END([End]) => id END, shape rect.

- I1["에이전트 수집"] => shape rect.

- I2["Batch Loader"] rect.

- I3["Stream Ingest"] rect.

- I4["Staging-RAW 적재"] rect.

- I5["Realtime-RAW 큐"] rect.

- I6{"지연>3s?"} => shape diamond (decision). So decisions list maybe includes these.

- I7["Backpressure 조절"] rect.

- I8["실시간 정제"] rect.

- I9["배치 정제"] rect.

- G1["스키마 검증"] rect.

- G2{"결측률>5%?"} diamond.

- G3["대체/삭제"] rect.

- G4["유효성 승인"] rect.

- GS1["PII 탐지"] rect.

- GS2["마스킹"] rect.

- GS3["권한 라벨"] rect.

- G_OUT["QC/SEC 통과"] rect.

- P1["포맷 식별"] rect.

- P2["JSON/CSV/XML 파싱"] rect.

- P3["스키마 매핑"] rect.

- N1["타입 캐스팅"] rect.

- N2["스케일링"] rect.

- N3["카테고리 인코딩"] rect.

- F1["피쳐 선택"] rect.

- F2["피쳐 결합"] rect.

- F3["피쳐 검증"] rect.

- PROC_OUT["PROC 완료"] rect.

- H1[("KV-Cache")] => shape circle? Actually ( ) is circle. The label is KV-Cache. So shape circle.

- H2[("Feature Store")] circle.

- C1[("Data Lake - Bronze")] circle.

- C2[("Lake - Silver")] circle.

- C3[("Lake - Gold")] circle.

- ST_OUT["저장 완료"] rect.

- T1["데이터 로더"] rect.

- T2["학습 파이프라인"] rect.

- T3{"성능 AUC>=0.90?"} diamond.

- T4["아티팩트 저장"] rect.

- T5["하이퍼파라미터 탐색"] rect.

- SV1["모델 레지스트리 조회"] rect.

- SV2["카나리 배포(10%)"] rect.

- SV3{"오류율<1%?"} diamond.

- SV4["전면배포(100%)"] rect.

- SV5["롤백"] rect.

- SV_OUT["서빙 활성"] rect.

- M1["지표수집"] rect.

- M2["성능/드리프트 감지"] rect.

- M3{"드리프트>0.1?"} diamond.

- M4["알림&차단"] rect.

- M5["세이프가드 정책"] rect.

- M6["정상 상태 유지"] rect.

- M_OUT["조치 완료"] rect.

- O1["스케줄러"] rect.

- O2["워크플로우 엔진"] rect.

- O3{"재시도 필요?"} diamond.

- O4["Retry w/Backoff"] rect.

- O5["휴지"] rect.

- O_OUT["오케스트레이션 완료"] rect.

- R_GATE{"데이터 라우팅"} diamond? Actually {} => diamond.

- S_ING subgraph id S_ING, title "INGEST (수집 레이어)". Subgraph nodes inside.

- S_GOV subgraph id S_GOV, title "GOV (품질/거버넌스)".

- S_GOV_QC subgraph id S_GOV_QC, title "QC(품질검증)". But subgraph list only includes top-level subgraphs? The schema "subgraphs": list of objects with id and title. Probably include all subgraphs defined, including nested ones. We'll include all.

- S_GOV_SEC id S_GOV_SEC, title "SEC(보안/마스킹)".

- S_PROC id S_PROC, title "PROC (처리 레이어)".

- S_PARSE id S_PARSE, title "PARSE".

- S_NORM id S_NORM, title "NORMALIZE".

- S_FEAT id S_FEAT, title "FEATUREIZE".

- S_STORE id S_STORE, title "STORE (저장소)".

- S_HOT id S_HOT, title "HOT-DB".

- S_COLD id S_COLD, title "COLD-LAKE".

- S_TRAIN id S_TRAIN, title "TRAIN (학습/튜닝)".

- S_SERVE id S_SERVE, title "SERVE (배포/서빙)".

- S_MON id S_MON, title "MON (관측/모니터링)".

- S_CTRL id S_CTRL, title "CTRL (제어/오케스트레이션)".

Now edges: need to list all connections with source, target, type, label. Type is "-->" for directed arrow. Some edges have labels like "배치", "실시간". Also decision edges have "-- Yes -->" etc. So label should be "Yes" or "No" accordingly. Also edges with label "배치" etc.

We must capture all edges defined.

Let's enumerate edges in order:

1. START --> R_GATE (type "-->", label null)

2. R_GATE -- "배치" --> S_ING (label "배치")

3. R_GATE -- "실시간" --> S_ING (label "실시간") (duplicate target but separate edge)

4. S_ING --> S_GOV

5. S_GOV --> S_PROC

6. S_PROC --> S_STORE

7. S_STORE --> S_TRAIN

8. S_TRAIN --> S_SERVE

9. S_SERVE --> S_MON

10. S_MON --> S_CTRL

11. S_ING --> G1 (edge from subgraph to node G1) label null

12. GS3 --> S_PROC label null

13. PROC_OUT --> H2 label null

14. C2 --> S_TRAIN label null

15. T4 --> S_SERVE label null

16. SV4 --> M1 label null

17. M4 --> S_SERVE label null

18. M5 --> T2 label null

19. O1 --> S_ING label null

20. O2 --> G1 label null

21. O_OUT --> M1 label null

Now internal edges within subgraphs:

S_ING internal:

- I1 --> I2

- I1 --> I3

- I2 --> I4

- I3 --> I5

- I5 --> I6

- I6 -- Yes --> I7

- I7 --> I5

- I6 -- No --> I8

- I4 --> I9

- I5 --> I6 (already captured earlier? Actually I5 --> I6 is already edge 5? Wait we have I5 --> I6 earlier; we listed as part of internal edges. Already captured as edge.

- I7 --> I5 (loop) captured.

- Also I5 --> I6 (duplicate? Already there). We'll include once.

- I5 --> I6 is edge.

- I5 --> I6 already.

- I5 --> I6 is part of internal.

- I5 --> I6 is already.

- I5 --> I6.

- I5 --> I6.

Ok.

S_GOV internal:

- G1 --> G2

- G2 -- Yes --> G3

- G3 --> G4

- G2 -- No --> G4

- G4 --> GS1

- GS1 --> GS2

- GS2 --> GS3

- GS3 --> G_OUT

S_GOV_QC internal edges are those above.

S_GOV_SEC internal edges are GS1->GS2->GS3.

S_PROC internal:

- P1 --> P2

- P2 --> P3

- N1 --> N2

- N2 --> N3

- F1 --> F2

- F2 --> F3

- P3 --> N1

- N1 --> F1

- F3 --> PROC_OUT

Also subgraph connections: P3 --> N1 --> F1 (so edges P3->N1, N1->F1). Already captured.

S_STORE internal:

- H1 --> H2

- C1 --> C2

- C2 --> C3

- H2 --> ST_OUT

- C3 --> ST_OUT

S_TRAIN internal:

- T1 --> T2

- T2 --> T3

- T3 -- Yes --> T4

- T3 -- No --> T5

- T5 --> T2

S_SERVE internal:

- SV1 --> SV2

- SV2 --> SV3

- SV3 -- Yes --> SV4

- SV3 -- No --> SV5

- SV5 --> SV1

- SV4 --> SV_OUT

S_MON internal:

- M1 --> M2

- M2 --> M3

- M3 -- Yes --> M4

- M4 --> M5

- M5 --> M_OUT

- M3 -- No --> M6

- M6 --> M_OUT

S_CTRL internal:

- O1 --> O2

- O2 --> O3

- O3 -- Yes --> O4

- O4 --> O2

- O3 -- No --> O5

- O2 --> O_OUT

Now also edges: I5 --> I6 (already), I6 --> I7 (Yes), I6 --> I8 (No). Already captured.

Also edges: I5 --> I6 (we have). Also I5 --> I6 is part of loop.

Edge: I5 --> I6 (already). Edge: I5 --> I6.

Edge: I5 --> I6.

Ok.

Edge: I5 --> I6 (duplicate). We'll include once.

Edge: I5 --> I6.

Now edges: I5 --> I6 (source I5, target I6, label null). I6 --> I7 label "Yes". I6 --> I8 label "No". I7 --> I5 label null.

Edge: I5 --> I6 (null). I6 --> I7 (Yes). I6 --> I8 (No). I7 --> I5 (null).

Edge: I5 --> I6 (null) already.

Edge: I5 --> I6.

Now edges: I5 --> I6 (null). Good.

Edge: I5 --> I6.

Now edges: I5 --> I6.

Ok.

Edge: I5 --> I6.

Now edges: I5 --> I6.

Now edges: I5 --> I6.

Stop.

Now decisions list: Should include nodes that are decision (diamond). So list of node ids: I6, G2, T3, SV3, M3, O3, G2 already, maybe also R_GATE? R_GATE is diamond ({}). So include R_GATE as decision. Also G2, I6, T3, SV3, M3, O3, G2 (already), maybe also G2 is decision. Also G2, I6, T3, SV3, M3, O3, G2, G2 duplicate. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2. Also G2, I6, T3, SV3, M3, O3, G2, G2.

Also G2, I6, T3, SV3, M3, O3, G2, G2.

Also G2, I6, T3, SV3, M3, O3, G2, G2.

Also G2, I6, T3, SV3, M3, O3, G2,