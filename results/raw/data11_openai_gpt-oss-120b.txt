We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (maybe decision nodes?), summary.

We must map shapes: [] = "rect", {} = "diamond", () = "circle", (()) = "double_circle", [[]] = "double_rect", >> = "subroutine". In the diagram, nodes are defined with various brackets:

- START([Start]) => label "Start", shape rect (since []), id "START"? Actually node id is START. So shape rect.

- END([End]) => id END, shape rect.

- I1["에이전트 수집"] => shape rect.

- I2["Batch Loader"] rect.

- I3["Stream Ingest"] rect.

- I4["Staging-RAW 적재"] rect.

- I5["Realtime-RAW 큐"] rect.

- I6{"지연>3s?"} => shape diamond (decision). So decisions list maybe includes these.

- I7["Backpressure 조절"] rect.

- I8["실시간 정제"] rect.

- I9["배치 정제"] rect.

- G1["스키마 검증"] rect.

- G2{"결측률>5%?"} diamond.

- G3["대체/삭제"] rect.

- G4["유효성 승인"] rect.

- GS1["PII 탐지"] rect.

- GS2["마스킹"] rect.

- GS3["권한 라벨"] rect.

- G_OUT["QC/SEC 통과"] rect.

- P1["포맷 식별"] rect.

- P2["JSON/CSV/XML 파싱"] rect.

- P3["스키마 매핑"] rect.

- N1["타입 캐스팅"] rect.

- N2["스케일링"] rect.

- N3["카테고리 인코딩"] rect.

- F1["피쳐 선택"] rect.

- F2["피쳐 결합"] rect.

- F3["피쳐 검증"] rect.

- PROC_OUT["PROC 완료"] rect.

- H1[("KV-Cache")] => shape circle? Actually ( ) is circle. The label is KV-Cache. So shape circle.

- H2[("Feature Store")] circle.

- C1[("Data Lake - Bronze")] circle.

- C2[("Lake - Silver")] circle.

- C3[("Lake - Gold")] circle.

- ST_OUT["저장 완료"] rect.

- T1["데이터 로더"] rect.

- T2["학습 파이프라인"] rect.

- T3{"성능 AUC>=0.90?"} diamond.

- T4["아티팩트 저장"] rect.

- T5["하이퍼파라미터 탐색"] rect.

- SV1["모델 레지스트리 조회"] rect.

- SV2["카나리 배포(10%)"] rect.

- SV3{"오류율<1%?"} diamond.

- SV4["전면배포(100%)"] rect.

- SV5["롤백"] rect.

- SV_OUT["서빙 활성"] rect.

- M1["지표수집"] rect.

- M2["성능/드리프트 감지"] rect.

- M3{"드리프트>0.1?"} diamond.

- M4["알림&차단"] rect.

- M5["세이프가드 정책"] rect.

- M6["정상 상태 유지"] rect.

- M_OUT["조치 완료"] rect.

- O1["스케줄러"] rect.

- O2["워크플로우 엔진"] rect.

- O3{"재시도 필요?"} diamond.

- O4["Retry w/Backoff"] rect.

- O5["휴지"] rect.

- O_OUT["오케스트레이션 완료"] rect.

- R_GATE{"데이터 라우팅"} diamond? Actually {} => diamond.

- S_ING subgraph id "S_ING" title "INGEST (수집 레이어)". Subgraph nodes inside.

- S_GOV subgraph id "S_GOV" title "GOV (품질/거버넌스)". Also nested subgraphs S_GOV_QC and S_GOV_SEC.

- S_GOV_QC subgraph id "S_GOV_QC" title "QC(품질검증)". S_GOV_SEC id "S_GOV_SEC" title "SEC(보안/마스킹)".

- S_PROC id "S_PROC" title "PROC (처리 레이어)". Inside subgraphs S_PARSE, S_NORM, S_FEAT.

- S_PARSE id "S_PARSE" title "PARSE". S_NORM id "S_NORM" title "NORMALIZE". S_FEAT id "S_FEAT" title "FEATUREIZE".

- S_STORE id "S_STORE" title "STORE (저장소)". Inside S_HOT and S_COLD.

- S_HOT id "S_HOT" title "HOT-DB". S_COLD id "S_COLD" title "COLD-LAKE".

- S_TRAIN id "S_TRAIN" title "TRAIN (학습/튜닝)".

- S_SERVE id "S_SERVE" title "SERVE (배포/서빙)".

- S_MON id "S_MON" title "MON (관측/모니터링)".

- S_CTRL id "S_CTRL" title "CTRL (제어/오케스트레이션)".

We need to list subgraphs in "subgraphs" array with id and title. Probably include all subgraphs (including nested). The schema expects subgraphs list of objects with id and title.

Edges: need to capture all connections. Edge type is "-->" as per schema. Some edges have labels like "배치", "실시간". Those should be captured in label field. For decision branches, edges like I6 -- Yes --> I7. So source I6, target I7, type "-->", label "Yes". Similarly No.

Also edges like R_GATE -- "배치" --> S_ING. So label "배치". For edges without label, label null.

We also have loops: I5 --> I6, I7 --> I5, etc.

We need to include all edges.

Decisions: maybe list decision node ids? The schema has "decisions": [] maybe list ids of decision nodes. We'll include ids of nodes with shape diamond: I6, G2, T3, SV3, M3, O3, R_GATE? R_GATE is also diamond but it's a routing node, maybe considered decision. We'll include all diamond nodes.

Summary: natural_language brief description. entry_nodes ["START"], exit_nodes ["END"].

Now we need to produce JSON with fields: ok true, warnings [].

Now compile nodes list. Must include each node with id, label, shape, subgraphs [] (maybe list subgraph ids it belongs to?). The schema says subgraphs: [] maybe list subgraph ids containing node. Could be empty for all. We'll set empty.

Now compile edges list.

Let's enumerate edges in order:

1. START --> R_GATE (type "-->", label null)

2. R_GATE -- "배치" --> S_ING (subgraph as target? Edge to subgraph id). So source R_GATE, target S_ING, label "배치".

3. R_GATE -- "실시간" --> S_ING (label "실시간").

4. S_ING --> S_GOV (null label)

5. S_GOV --> S_PROC

6. S_PROC --> S_STORE

7. S_STORE --> S_TRAIN

8. S_TRAIN --> S_SERVE

9. S_SERVE --> S_MON

10. S_MON --> S_CTRL

11. S_ING --> G1 (null label) (G1 is inside S_GOV_QC but edge to node)

12. GS3 --> S_PROC

13. PROC_OUT --> H2

14. C2 --> S_TRAIN

15. T4 --> S_SERVE

16. SV4 --> M1

17. M4 --> S_SERVE

18. M5 --> T2

19. O1 --> S_ING

20. O2 --> G1

21. O_OUT --> M1

22. I5 --> I6

23. I6 -- Yes --> I7

24. I7 --> I5

25. I6 -- No --> I8

26. I5 --> I6? Already have I5 --> I6 (edge 22). Also I5 --> I6? Already.

27. I5 --> I6? Already.

28. I5 --> I6? No duplicate.

29. I5 --> I6? okay.

30. I5 --> I6? done.

31. I5 --> I6? done.

Now other edges inside subgraphs:

- I1 --> I2

- I1 --> I3

- I2 --> I4

- I3 --> I5

- I4 --> I9

- I5 --> I6 (already captured)

- I6 -- Yes --> I7 (captured)

- I6 -- No --> I8 (captured)

- I7 --> I5 (captured)

- I8? No outgoing? Not in diagram.

- I9? No outgoing.

- G1 --> G2

- G2 -- Yes --> G3

- G3 --> G4

- G2 -- No --> G4

- G4 --> GS1

- GS1 --> GS2

- GS2 --> GS3

- GS3 --> G_OUT

- P1 --> P2

- P2 --> P3

- P3 --> N1

- N1 --> N2

- N2 --> N3

- N3 --> F1? Actually N3 --> F1? Wait diagram: N3 --> ??? Actually they have "N3 --> ???". In code: N2 --> N3["카테고리 인코딩"] . Then later: P3 --> N1 --> F1 . So N3 not directly to F1. So after N3, maybe no edge. So we have N3 no outgoing.

- F1 --> F2

- F2 --> F3

- F3 --> PROC_OUT

- H1 --> H2

- C1 --> C2

- C2 --> C3

- H2 --> ST_OUT

- C3 --> ST_OUT

- T1 --> T2

- T2 --> T3

- T3 -- Yes --> T4

- T3 -- No --> T5

- T5 --> T2

- T4? No outgoing except edge to S_SERVE (captured earlier)

- SV1 --> SV2

- SV2 --> SV3

- SV3 -- Yes --> SV4

- SV3 -- No --> SV5

- SV5 --> SV1

- SV4 --> SV_OUT

- M1 --> M2

- M2 --> M3

- M3 -- Yes --> M4

- M4 --> M5

- M5 --> M_OUT

- M3 -- No --> M6

- M6 --> M_OUT

- O1 --> O2

- O2 --> O3

- O3 -- Yes --> O4

- O4 --> O2

- O3 -- No --> O5

- O2 --> O_OUT

- R_GATE --> ??? Already.

- S_ING --> ??? Already.

- S_ING --> G1 (captured)

- GS3 --> S_PROC (captured)

- PROC_OUT --> H2 (captured)

- C2 --> S_TRAIN (captured)

- T4 --> S_SERVE (captured)

- SV4 --> M1 (captured)

- M4 --> S_SERVE (captured)

- M5 --> T2 (captured)

- O1 --> S_ING (captured)

- O2 --> G1 (captured)

- O_OUT --> M1 (captured)

- M2 --> M3 --> M2? Actually they have M2 --> M3 --> M2 (loop). So edges: M2 --> M3, M3 --> M2 (label? Not specified). So we need edge M3 --> M2 with label null.

- SV5 --> SV1 (captured)

- T5 --> T2 (captured)

- M5 --> T1 (captured)

- S_CTRL --> END (captured)

- START --> R_GATE (captured)

Now also edges: I5 --> I6 (already). I5 --> I6? Already.

Edge: I5 --> I6? Already.

Edge: I5 --> I6? done.

Edge: I5 --> I6? okay.

Edge: I5 --> I6? done.

Edge: I5 --> I6? done.

Edge: I5 --> I6? done.

Now also edge: I5 --> I6? done.

Edge: I5 --> I6? done.

Now also edge: I5 --> I6? done.

Now also edge: I5 --> I6? done.

Now also edge: I5 --> I6? done.

Ok.

Now we need to list all nodes. Let's compile list of node ids and labels.

List:

START, END, R_GATE, I1, I2, I3, I4, I5, I6, I7, I8, I9, G1, G2, G3, G4, GS1, GS2, GS3, G_OUT, P1, P2, P3, N1, N2, N3, F1, F2, F3, PROC_OUT, H1, H2, C1, C2, C3, ST_OUT, T1, T2, T3, T4, T5, SV1, SV2, SV3, SV4, SV5, SV_OUT, M1, M2, M3, M4, M5, M6, M_OUT, O1, O2, O3, O4,