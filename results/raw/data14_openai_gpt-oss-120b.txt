We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (maybe decision nodes?), summary.

We need to extract all nodes: each node defined with label syntax: e.g., START([Start]) => shape rect (since []), label "Start". ID is "START". Similarly END([End]).

Subgraphs: each subgraph defined: subgraph S_DATA["DATA MGMT"] etc. So subgraph id S_DATA, title "DATA MGMT". Also nested subgraphs: S_EXP contains subgraphs S_RUN["실험 실행"] and S_TRACK["추적/버저닝"]; also S_COMP contains S_SCH["스케줄링"] and S_MON["모니터링"]; etc. So we need to list all subgraphs (including nested). The schema expects subgraphs array with objects id and title.

Nodes: need to list each node with id, label, shape, subgraphs (list of subgraph ids that contain this node?). The schema includes "subgraphs": [] for each node. We should include which subgraphs the node belongs to (maybe hierarchical). For simplicity, we can include immediate parent subgraph(s). For nested nodes, they belong to both outer and inner? Could include both. But not required? The schema expects subgraphs array; we can fill with list of subgraph ids that node is part of. Let's include all containing subgraphs (outermost to innermost). For nodes not in any subgraph, empty.

Edges: need source, target, type, label. Type is "-->" for normal arrow, maybe "--" for decision? In diagram, they use "-->" for all connections, also decision edges like D3 -- No --> D4. That's also "--". Actually syntax: D3 -- No --> D4. So type is "--". The label is "No". For edges without label, label null.

Decisions: maybe list decision nodes (diamond shape). The schema includes "decisions": [] but not defined. Could list nodes that are decisions? Probably include node ids of decision nodes. Let's include each decision node id with label maybe. But schema expects array of objects? Not defined. Could be empty. Safer to leave empty array.

Summary: natural_language brief description, entry_nodes ["START"], exit_nodes ["END"].

Warnings: empty.

Ok.

Now compile nodes.

List all nodes:

From top:

START, HUB, END.

Subgraph S_DATA nodes: D1, D2, D3, D4, D5.

S_EXP: includes subgraph S_RUN nodes: E1, E2, E3, E4, E_OK. Also subgraph S_TRACK nodes: ET1, ET2.

S_COMP: subgraph S_SCH nodes: C1, C2, C3, C4. Subgraph S_MON nodes: C5, C6, C7, C_OK.

S_IRB nodes: R1, R2, R3, R_OK.

S_PUB nodes: P1, P2, P3, P4, P5, P6, P7, P8, P9, P_OK.

S_COL nodes: L1, L2, L3, L4, L5, L6, L_OK.

S_GRANT nodes: G1, G2, G3, G4, G5, G6, G7, G_OK.

S_KB nodes: K1, K2, K3, K4, K_OK.

Also maybe nodes like "버전 스냅샷" D5 is a double parentheses? Actually D5[("버전 스냅샷")] uses parentheses inside brackets? Syntax: D5[("버전 스냅샷")] => shape? The outer [] indicates rect, inside parentheses maybe just part of label. So shape rect.

Similarly E_OK["모델 후보"] rect.

C_OK["정상"] rect.

R_OK["승인"] rect.

P_OK["게재"] rect.

L_OK["릴리즈 태그"] rect.

G_OK["예산 집행"] rect.

K_OK["게시"] rect.

Now shapes: [] => rect, {} => diamond, () => circle, (()) => double_circle, [[]] => double_rect, >> => subroutine.

Thus decision nodes: D3, E4, C2, C6, R2, P4, L4, G3, G6, K3. Also maybe others: C2 {"GPU 가용?"} diamond. C6 {"오류/OOM?"} diamond. etc.

Now edges: need to list all connections.

Let's enumerate.

Top-level edges:

START --> HUB (type "-->", label null)

HUB -- 데이터 --> S_DATA (source HUB, target S_DATA, type "--", label "데이터")

HUB -- 실험 --> S_EXP

HUB -- 컴퓨트 --> S_COMP

HUB -- 윤리 --> S_IRB

HUB -- 출판 --> S_PUB

HUB -- 협업 --> S_COL

H HUB -- 그랜트 --> S_GRANT

H HUB -- 지식 --> S_KB

Now edges within subgraphs.

S_DATA subgraph:

D1 --> D2

D2 --> D3

D3 -- No --> D4

D4 --> D2

D3 -- Yes --> D5

Now edges from S_DATA to other nodes:

S_DATA --> E1 (source S_DATA, target E1, type "-->", label null)

D5 --> C1

Now S_EXP subgraph:

Inside S_RUN:

E1 --> E2

E2 --> E3

E3 --> E4

E4 -- No --> E2

E4 -- Yes --> E_OK

Inside S_TRACK:

ET1 --> ET2

Also connections:

E2 --> ET1

E_OK --> ET2

Now S_COMP subgraph:

Inside S_SCH:

C1 --> C2

C2 -- No --> C3

C3 --> C1

C2 -- Yes --> C4

Inside S_MON:

C5 --> C6

C6 -- Yes --> C7

C7 --> C1

C6 -- No --> C_OK

Also connections:

C4 --> C5

Now S_IRB subgraph:

R1 --> R2

R2 -- Yes --> R3

R3 --> R1

R2 -- No --> R_OK

Now S_PUB subgraph:

P1 --> P2

P2 --> P3

P3 --> P4

P4 -- No --> P5

P5 --> P3

P4 -- Yes --> P6

P6 --> P7

P7 -- Reject --> P8

P8 --> P1

P7 -- Minor --> P9

P9 --> P6

P7 -- Accept --> P_OK

Now S_COL subgraph:

L1 --> L2

L2 --> L3

L3 --> L4

L4 -- No --> L5

L5 --> L3

L4 -- Yes --> L6

L6 --> L_OK

Now S_GRANT subgraph:

G1 --> G2

G2 --> G3

G3 -- No --> G4

G4 --> G2

G3 -- Yes --> G5

G5 --> G6

G6 -- No --> G7

G7 --> G2

G6 -- Yes --> G_OK

Now S_KB subgraph:

K1 --> K2

K2 --> K3

K3 -- Yes --> K4

K4 --> K2

K3 -- No --> K_OK

Now cross connections:

S_COMP --> E2 (source S_COMP, target E2, type "-->", label null)

R_OK --> P1

ET2 --> P2

S_COL --> P3

S_GRANT --> P1

K_OK --> P3

C7 --> C1 (already defined earlier as part of S_MON? Actually C7 --> C1 already defined; but we have that edge already. It's okay duplicate? Already defined as part of S_MON: C7 --> C1. So we already have.

E4 --> E2 (already defined as part of S_RUN: E4 -- No --> E2). Already captured.

P5 --> P3 (already captured as part of P4 No path: P5 --> P3). Already captured.

P8 --> P1 (already captured as part of P7 Reject path). Already captured.

L5 --> L3 (already captured as part of L4 No path). Already captured.

G7 --> G2 (already captured as part of G6 No path). Already captured.

K4 --> K2 (already captured as part of K3 Yes path). Already captured.

Cross feedback edges:

P2 --> K1

K_OK --> L1

R1 --> K1

P7 --> K1

Now termination edges:

P_OK --> END

L_OK --> END

G_OK --> END

C_OK --> END

Also maybe other exit nodes? Not needed.

Now we need to list edges with type and label.

Edge type: For arrows with label, they use "-- label -->". So type is "--". For simple arrows without label, they use "-->" (type "-->"). We'll follow that.

Now compile edges list.

Let's enumerate systematically.

I'll create list:

1. START --> HUB (type "-->", label null)

2. HUB -- 데이터 --> S_DATA (type "--", label "데이터")

3. HUB -- 실험 --> S_EXP

4. HUB -- 컴퓨트 --> S_COMP

5. HUB -- 윤리 --> S_IRB

6. HUB -- 출판 --> S_PUB

7. HUB -- 협업 --> S_COL

8. HUB -- 그랜트 --> S_GRANT

9. HUB -- 지식 --> S_KB

10. D1 --> D2 (type "-->", null)

11. D2 --> D3

12. D3 -- No --> D4 (type "--", label "No")

13. D4 --> D2

14. D3 -- Yes --> D5 (type "--", label "Yes")

15. S_DATA --> E1 (type "-->", null)

16. D5 --> C1

17. C1 --> C2

18. C2 -- No --> C3

19. C3 --> C1

20. C2 -- Yes --> C4

21. C4 --> C5

22. C5 --> C6

23. C6 -- Yes --> C7

24. C7 --> C1 (already captured but include)

25. C6 -- No --> C_OK

26. E1 --> E2

27. E2 --> E3

28. E3 --> E4

29. E4 -- No --> E2

30. E4 -- Yes --> E_OK

31. ET1 --> ET2

32. E2 --> ET1

33. E_OK --> ET2

34. R1 --> R2

35. R2 -- Yes --> R3

36. R3 --> R1

37. R2 -- No --> R_OK

38. P1 --> P2

39. P2 --> P3

40. P3 --> P4

41. P4 -- No --> P5

42. P5 --> P3

43. P4 -- Yes --> P6

44. P6 --> P7

45. P7 -- Reject --> P8

46. P8 --> P1

47. P7 -- Minor --> P9

48. P9 --> P6

49. P7 -- Accept --> P_OK

50. L1 --> L2

51. L2 --> L3

52. L3 --> L4

53. L4 -- No --> L5

54. L5 --> L3

55. L4 -- Yes --> L6

56. L6 --> L_OK

57. G1 --> G2

58. G2 --> G3

59. G3 -- No --> G4

60. G4 --> G2

61. G3 -- Yes --> G5

62. G5 --> G6

63. G6 -- No --> G7

64. G7 --> G2

65. G6 -- Yes --> G_OK

66. K1 --> K2

67. K2 --> K3

68. K3 -- Yes --> K4

69. K4 --> K2

70. K3 -- No --> K_OK

71. S_COMP --> E2

72. R_OK --> P1

73. ET2 --> P2

74. S_COL --> P3

75. S_GRANT --> P1

76. K_OK --> P3

77. P2 --> K1

78. K_OK --> L1

79. R1 --> K1

80. P7 --> K1

81. P_OK --> END

82. L_OK --> END

83. G_OK --> END

84. C_OK --> END

Now also need edge S_DATA --> E1 already captured.

Edge S_DATA --> E1 is #15.

Edge S_DATA --> E1 is type "-->", null.

Edge S_DATA --> E1 already.

Edge S_DATA --> E1 is fine.

Edge S_DATA --> E1.

Edge S_DATA --> E1.

Edge S_DATA --> E1.

Now also edge S_DATA --> E1 is captured.

Edge S_DATA --> E1.

Now also edge S_DATA --> E1.

Ok.

Now we need to list nodes with shape.

Define shape mapping:

- [] => rect

- {} => diamond

- () => circle

- (()) => double_circle

- [[]] => double_rect

- >> => subroutine

Thus for each node:

START: label "Start", shape rect.

HUB: label "워크로드 라우팅", shape diamond? Actually HUB{"워크로드 라우팅"} uses {} => diamond. So shape diamond.

END: label "End", shape rect.

D1: label "원천 수집", shape rect.

D2: "메타데이터 등록", rect.

D3: "품질 OK?" diamond.

D4: "정제/라벨 수정", rect.

D5: "버전 스냅샷", rect.

E1: "전처