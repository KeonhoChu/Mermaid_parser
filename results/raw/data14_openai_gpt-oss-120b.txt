We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (maybe decision nodes?), summary.

We need to extract all nodes: each node defined with label and shape based on brackets.

Mapping: [] = rect, {} = diamond, () = circle, (()) = double_circle, [[]] = double_rect, >> = subroutine.

We need to list nodes with id, label, shape, subgraphs (list of subgraph ids they belong to?). The schema includes subgraphs field per node, but we can maybe leave empty list if not needed. Probably we need to include subgraph membership.

Edges: source, target, type (the arrow type). In Mermaid, edges are defined with -->, --, etc. Use "-->" as type. Label may be null unless edge has label (e.g., "No", "Yes", "Reject", etc). Those are labels on edges. So we need to capture label.

Decisions: maybe nodes that are diamond shape? The schema includes decisions array; maybe list decision node ids? Could be empty.

Subgraphs: list each subgraph with id and title. Subgraph ids are like S_DATA, S_EXP, etc. Title is the string inside quotes after subgraph id: e.g., "DATA MGMT". So we need to list all subgraphs.

We also need summary: natural_language brief description, entry_nodes ["START"], exit_nodes ["END"].

We must output valid JSON only.

Now parse nodes.

List all node definitions:

START([Start]) => id START, label "Start", shape rect (since []), subgraphs [].

END([End]) => id END, label "End", shape rect.

Now subgraph S_DATA "DATA MGMT": nodes inside:

D1["원천 수집"] => id D1, label "원천 수집", shape rect.

D2["메타데이터 등록"] => rect.

D3{"품질 OK?"} => diamond.

D4["정제/라벨 수정"] => rect.

D5[("버전 스냅샷")] => shape circle? Actually [("...")] means outer [] with inner (). The syntax: [("text")] is a rectangle containing a circle? In Mermaid, parentheses inside brackets produce a circle shape? Actually shape mapping: () = circle, [] = rect. If you have [("text")] it's a rectangle with a circle? Not standard. Probably treat as circle? But mapping says [] = rect, () = circle. The node is defined as [("버전 스냅샷")]; the outer [] indicates rect, inner () maybe just part of label. I'd treat shape rect. But maybe they intend double shape? Not sure. Safer to treat as rect because outer [].

But there is also node E_OK["모델 후보"] etc.

Let's list all nodes.

Subgraph S_EXP "EXPERIMENTS": contains subgraph S_RUN "실험 실행" and S_TRACK "추적/버저닝". Nodes:

E1["전처리 파이프"] rect.

E2["학습"] rect.

E3["평가"] rect.

E4{"목표 달성?"} diamond.

E_OK["모델 후보"] rect.

ET1["파라미터/메트릭 로깅"] rect.

ET2["아티팩트 저장소"] rect.

Subgraph S_COMP "COMPUTE CLUSTER": subgraphs S_SCH "스케줄링" and S_MON "모니터링". Nodes:

C1["큐 등록"] rect.

C2{"GPU 가용?"} diamond.

C3["대기/프리엠션"] rect.

C4["노드 할당"] rect.

C5["리소스 모니터"] rect.

C6{"오류/OOM?"} diamond.

C7["자동 중단/재시작"] rect.

C_OK["정상"] rect.

Subgraph S_IRB "ETHICS/IRB": nodes:

R1["프로토콜 제출"] rect.

R2{"보완 필요?"} diamond.

R3["수정 반영"] rect.

R_OK["승인"] rect.

Subgraph S_PUB "PUBLICATION": nodes:

P1["원고 초안"] rect.

P2["실험표 정리"] rect.

P3["그림/부록 생성"] rect.

P4{"저널 포맷 충족?"} diamond.

P5["포맷 수정"] rect.

P6["투고"] rect.

P7{"리뷰 결과"} diamond? Actually it's {"리뷰 결과"}? In diagram: P7{"리뷰 결과"}? Actually they wrote P7{"리뷰 결과"}? Let's check: "P7{"리뷰 결과"}". In code: P7{"리뷰 결과"}? The snippet: P7{"리뷰 결과"}? Actually they wrote: P7{"리뷰 결과"}? Let's scroll: In the flowchart: 
```
P6["투고"] --> P7{"리뷰 결과"}
P7 -- Reject --> P8["대폭수정"] --> P1
P7 -- Minor --> P9["경미수정"] --> P6
P7 -- Accept --> P_OK["게재"]
```
So P7 is a diamond decision node.

P8["대폭수정"] rect.

P9["경미수정"] rect.

P_OK["게재"] rect.

Subgraph S_COL "COLLAB & REPO": nodes:

L1["이슈 등록"] rect.

L2["브랜치 생성"] rect.

L3["PR 제출"] rect.

L4{"리뷰 통과?"} diamond.

L5["수정"] rect.

L6["병합"] rect.

L_OK["릴리즈 태그"] rect.

Subgraph S_GRANT "GRANT MGMT": nodes:

G1["공고 탐색"] rect.

G2["제안서 작성"] rect.

G3{"내부 승인?"} diamond.

G4["수정/재검토"] rect.

G5["제출"] rect.

G6{"선정?"} diamond.

G7["피드백 반영"] rect.

G_OK["예산 집행"] rect.

Subgraph S_KB "KNOWLEDGE BASE": nodes:

K1["노트 업로드"] rect.

K2["태깅/검색 인덱스"] rect.

K3{"중복/품질?"} diamond.

K4["정제/합치기"] rect.

K_OK["게시"] rect.

Now also HUB{"워크로드 라우팅"} => diamond.

Now edges: need to capture all connections.

List edges in order.

From top:

START --> HUB (type "-->", label null)

HUB -- 데이터 --> S_DATA (edge label "데이터")

HUB -- 실험 --> S_EXP

HUB -- 컴퓨트 --> S_COMP

HUB -- 윤리 --> S_IRB

HUB -- 출판 --> S_PUB

HUB -- 협업 --> S_COL

HUB -- 그랜트 --> S_GRANT

HUB -- 지식 --> S_KB

Now within S_DATA:

D1 --> D2

D2 --> D3

D3 -- No --> D4

D4 --> D2

D3 -- Yes --> D5

Now subgraph connections:

S_DATA --> E1 (edge from subgraph to node). Source is S_DATA (subgraph id) target E1, label null.

D5 --> C1

S_COMP --> E2

R_OK --> P1

ET2 --> P2

S_COL --> P3

S_GRANT --> P1

K_OK --> P3

Now feedback loops:

C7 --> C1

E4 --> E2

P5 --> P3

P8 --> P1

L5 --> L3

G7 --> G2

K4 --> K2

Cross feedback:

P2 --> K1

K_OK --> L1

R1 --> K1

P7 --> K1

Now within S_EXP:

Inside S_RUN:

E1 --> E2

E2 --> E3

E3 --> E4

E4 -- No --> E2

E4 -- Yes --> E_OK

Inside S_TRACK:

ET1 --> ET2

Now connections between subgraphs:

E2 --> ET1

E_OK --> ET2

Now within S_COMP:

Inside S_SCH:

C1 --> C2

C2 -- No --> C3

C3 --> C1

C2 -- Yes --> C4

Inside S_MON:

C5 --> C6

C6 -- Yes --> C7

C6 -- No --> C_OK

C4 --> C5

Now within S_IRB:

R1 --> R2

R2 -- Yes --> R3

R3 --> R1

R2 -- No --> R_OK

Now within S_PUB:

P1 --> P2

P2 --> P3

P3 --> P4

P4 -- No --> P5

P5 --> P3

P4 -- Yes --> P6

P6 --> P7

P7 -- Reject --> P8

P8 --> P1

P7 -- Minor --> P9

P9 --> P6

P7 -- Accept --> P_OK

Now within S_COL:

L1 --> L2

L2 --> L3

L3 --> L4

L4 -- No --> L5

L5 --> L3

L4 -- Yes --> L6

L6 --> L_OK

Now within S_GRANT:

G1 --> G2

G2 --> G3

G3 -- No --> G4

G4 --> G2

G3 -- Yes --> G5

G5 --> G6

G6 -- No --> G7

G7 --> G2

G6 -- Yes --> G_OK

Now within S_KB:

K1 --> K2

K2 --> K3

K3 -- Yes --> K4

K4 --> K2

K3 -- No --> K_OK

Now termination edges:

P_OK --> END

L_OK --> END

G_OK --> END

C_OK --> END

START --> HUB already captured.

Now also there is edge from S_DATA --> E1 (already captured). Also D5 --> C1 captured.

Now also S_COMP --> E2 captured.

Now also S_EXP? Not needed.

Now also S_COL --> P3 captured.

Now also S_GRANT --> P1 captured.

Now also K_OK --> P3 captured.

Now also K_OK --> L1 captured.

Now also R1 --> K1 captured.

Now also P7 --> K1 captured.

Now also P2 --> K1 captured.

Now also K_OK --> L1 captured (already).

Now also K_OK --> P3 captured.

Now also S_DATA --> E1 captured.

Now also S_COMP --> E2 captured.

Now also S_EXP? Not.

Now also S_IRB? Not.

Now also S_KB? Not.

Now also S_PUB? Not.

Now also S_COL? Already.

Now also S_GRANT? Already.

Now also S_DATA? Already.

Now also S_COMP? Already.

Now also S_EXP? Not needed.

Now also S_IRB? Not.

Now also S_KB? Not.

Now also S_PUB? Not.

Now also S_COL? Already.

Now also S_GRANT? Already.

Now also S_KB? Already.

Now also S_DATA? Already.

Now also S_COMP? Already.

Now also S_EXP? Not.

Now also S_IRB? Not.

Now also S_PUB? Not.

Now also S_COL? Already.

Now also S_GRANT? Already.

Now also S_KB? Already.

Now also S_DATA? Already.

Now also S_COMP? Already.

Now also S_EXP? Not.

Now also S_IRB? Not.

Now also S_PUB? Not.

Now also S_COL? Already.

Now also S_GRANT? Already.

Now also S_KB? Already.

Now also S_DATA? Already.

Ok.

Now we need to list nodes with subgraphs membership. For each node, we can list subgraph ids they belong to (maybe immediate subgraph). For simplicity, we can leave empty list for all nodes, as schema allows subgraphs: [].

But maybe they expect to list subgraph ids. Not required but could be.

We'll set subgraphs empty for all nodes.

Now decisions array: maybe list ids of decision nodes (diamond). Could include D3, E4, C2, C6, R2, P4, P7, L4, G3, G6, K3, HUB, etc. We'll include them.

Now summary natural_language: "Workflow for data management, experiments, compute, ethics, publication, collaboration, grant, and knowledge base with routing hub."

Now entry_nodes ["START"], exit_nodes ["END"].

Now warnings empty.

Now produce JSON.

Need to ensure proper escaping of Korean characters in JSON strings; they can be raw Unicode.

Now compile nodes list.

Let's enumerate all node ids:

START, END, HUB,
D1, D2, D3, D4, D5,
E1, E2, E3, E4, E_OK,
ET1, ET2,
C1, C2, C3, C4, C5, C6, C7, C_OK,
R1, R2, R3, R_OK,
P1, P2, P3, P4, P5, P6, P7, P8, P9, P_OK,
L1, L2, L3, L4, L5, L6, L_OK,
G1, G2, G3, G4, G5, G6, G7, G_OK,
K1, K2, K3, K4, K_OK

Check also any other nodes: maybe D5 is a node with shape rect; fine.

Now edges list: need to include all edges with source, target, type "-->", label (null or string). For edges with label like "No", "Yes", "Reject", "Minor", "Accept", "데이터", etc.

Now compile edges.

I'll create array.

Edge1: {"source":"