We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (empty?), summary.

We need to extract all nodes (including START, END, and all labeled nodes). Determine shape based on delimiters: [] => rect, {} => diamond, () => circle, (()) double_circle, [[]] double_rect, >> subroutine. In the diagram, nodes are defined like START([Start]) => label "Start" shape rect. HUB{"업무 도메인 라우팅"} => diamond shape. Others: SA1["리드 수집"] => rect. SA3{"성사?"} => diamond. etc.

Also subgraphs: each subgraph has id and title. For example: subgraph S_SALES["SALES"] => id "S_SALES", title "SALES". Inside there are nested subgraphs: subgraph S_SALES_PIPE["Sales-Pipe"] => id "S_SALES_PIPE", title "Sales-Pipe". Similarly for others.

We need to list all subgraphs (including nested). Probably include all subgraph definitions.

Edges: need to capture all connections. Edge syntax: -->, --, -- "label" -->? In Mermaid, edges can have labels like -- "주문" --> S_SALES. The schema expects "type": "-->", label maybe null or string. For labeled edges, we should capture label. The type is the arrow representation? In examples they use "-->" as type. For labeled edges, still type "-->"? Probably yes. So for each edge, source, target, type, label (null if none). For edges like SA3 -- Yes --> SA4, source SA3, target SA4, label "Yes". Type "-->"? The edge uses "-- Yes -->". So type is "-->", label "Yes". For edges like HUB -- "주문" --> S_SALES, label "주문". For edges like PY4 --> PY2 (no label) label null.

Also edges like BI4 --> BI5 --> BI4 is a loop: Actually "BI4 --> BI5 --> BI4" means BI4 to BI5, then BI5 to BI4. So we need two edges: BI4->BI5, BI5->BI4.

Similarly "CS3 --> CS5 --> CS1" yields CS3->CS5, CS5->CS1.

Also "RK4 --> RK5 --> RK2" yields RK4->RK5, RK5->RK2.

Also "BI4 --> BI5 --> BI4" already captured.

Also "PY4 --> PY2" already captured earlier as loop.

Also "LG5 --> LG3" loop.

Also "BI4 --> BI5 --> BI4" we have.

Also "RK4 --> CS1" edge.

Also "RK5 --> BI1" edge.

Also "BI4 --> RK1" edge.

Also "SA_OUT --> BI1" etc.

Also "PY_OUT --> BI1", "LG_OUT --> BI1", "CS_OUT --> BI1".

Also "S_SALES --> PY1" edge from subgraph to node? Source is subgraph id "S_SALES". So we treat subgraph as node? In schema, edges source and target are node ids. Subgraph ids can be used as source/target. So include them.

Similarly "PY3 --> S_LOGI", "LG_OUT --> S_CS", "S_CS --> BI1", "S_RISK --> PY2", "RK4 --> CS1", "RK5 --> BI1", "BI4 --> RK1", "SA_OUT --> BI1", "PY_OUT --> BI1", "LG_OUT --> BI1", "CS_OUT --> BI1". Also "S_SALES --> PY1". Also "PY3 --> S_LOGI". Also "LG_OUT --> S_CS". Also "S_CS --> BI1". Also "S_RISK --> PY2". Also "S_RISK" is subgraph id.

Also "S_SALES" etc.

Also "START --> HUB" and "BI_OUT --> END([End])". END node defined as End shape rect.

Now compile nodes list.

Let's enumerate all node ids and labels:

START: id "START", label "Start", shape rect.

HUB: id "HUB", label "업무 도메인 라우팅", shape diamond.

SA1: id "SA1", label "리드 수집", shape rect.

SA2: id "SA2", label "기회 생성", shape rect.

SA3: id "SA3", label "성사?", shape diamond.

SA4: id "SA4", label "주문 생성", shape rect.

SA5: id "SA5", label "후속캠페인", shape rect.

SA_OUT: id "SA_OUT", label "주문 완료", shape rect.

PY1: id "PY1", label "결제요청", shape rect.

PY2: id "PY2", label "승인?", shape diamond.

PY3: id "PY3", label "정산 예정", shape rect.

PY4: id "PY4", label "재시도/대체수단", shape rect.

PY_OUT: id "PY_OUT", label "정산 라인", shape rect.

LG1: id "LG1", label "피킹", shape rect.

LG2: id "LG2", label "패킹", shape rect.

LG3: id "LG3", label "출고", shape rect.

LG4: id "LG4", label "지연?", shape diamond.

LG5: id "LG5", label "경로 재계획", shape rect.

LG6: id "LG6", label "배송 진행", shape rect.

LG_OUT: id "LG_OUT", label "배송 추적", shape rect.

CS1: id "CS1", label "티켓 접수", shape rect.

CS2: id "CS2", label "우선순위?", shape diamond.

CS3: id "CS3", label "전담 처리", shape rect.

CS4: id "CS4", label "일반 처리", shape rect.

CS5: id "CS5", label "해결/콜백", shape rect.

CS_OUT: id "CS_OUT", label "CS 종료", shape rect.

RK1: id "RK1", label "피쳐수집", shape rect.

RK2: id "RK2", label "모델스코어링", shape rect.

RK3: id "RK3", label "위험>임계?", shape diamond.

RK4: id "RK4", label "차단/리뷰", shape rect.

RK5: id "RK5", label "정책업데이트", shape rect.

RK6: id "RK6", label "승인 통과", shape rect.

RK_OUT: id "RK_OUT", label "정책 반영", shape rect.

BI1: id "BI1", label "데이터 집계", shape rect.

BI2: id "BI2", label "대시보드 갱신", shape rect.

BI3: id "BI3", label "이상징후?", shape diamond.

BI4: id "BI4", label "알림/깃발", shape rect.

BI5: id "BI5", label "원인분석", shape rect.

BI6: id "BI6", label "정상 리포트", shape rect.

BI_OUT: id "BI_OUT", label "분석결과", shape rect.

END: id "END", label "End", shape rect.

Also maybe nodes for subgraph internal? No.

Now subgraphs list:

S_SALES: id "S_SALES", title "SALES"

S_SALES_PIPE: id "S_SALES_PIPE", title "Sales-Pipe"

S_PAY: id "S_PAY", title "PAYMENTS"

S_PAY_PROC: id "S_PAY_PROC", title "결제흐름"

S_LOGI: id "S_LOGI", title "LOGISTICS"

S_LOGI_FLOW: id "S_LOGI_FLOW", title "배송흐름"

S_CS: id "S_CS", title "CUSTOMER SUPPORT"

S_CS_PIPE: id "S_CS_PIPE", title "CS흐름"

S_RISK: id "S_RISK", title "RISK & FRAUD"

S_RISK_ENG: id "S_RISK_ENG", title "탐지엔진"

S_BI: id "S_BI", title "REPORTING/BI"

S_BI_PIPE: id "S_BI_PIPE", title "리포트"

Now edges list. Let's enumerate all edges in order.

From diagram:

START([Start]) --> HUB

HUB -- "주문" --> S_SALES

HUB -- "결제" --> S_PAY

HUB -- "물류" --> S_LOGI

HUB -- "CS" --> S_CS

HUB -- "리스크" --> S_RISK

HUB -- "리포팅" --> S_BI

Now within subgraphs:

SA1 --> SA2

SA2 --> SA3

SA3 -- Yes --> SA4

SA3 -- No --> SA5

SA5 --> SA2

SA4 --> SA_OUT

PY1 --> PY2

PY2 -- Yes --> PY3

PY2 -- No --> PY4

PY4 --> PY2 (also later loop but same)

PY3 --> PY_OUT

LG1 --> LG2

LG2 --> LG3

LG3 --> LG4

LG4 -- Yes --> LG5

LG5 --> LG3

LG4 -- No --> LG6

LG6 --> LG_OUT

CS1 --> CS2

CS2 -- High --> CS3

CS2 -- Normal --> CS4

CS3 --> CS5

CS4 --> CS5

CS5 --> CS_OUT

RK1 --> RK2

RK2 --> RK3

RK3 -- Yes --> RK4

RK4 --> RK5

RK5 --> RK_OUT

RK3 -- No --> RK6

BI1 --> BI2

BI2 --> BI3

BI3 -- Yes --> BI4

BI4 --> BI5

BI5 --> BI4 (loop)

BI3 -- No --> BI6

BI6 --> BI_OUT

BI5 --> BI_OUT (actually BI5 --> BI_OUT? In diagram: BI5 --> BI_OUT["분석결과"]; yes edge BI5 -> BI_OUT)

BI6 --> BI_OUT (already)

Now cross-domain edges:

S_SALES --> PY1

PY3 --> S_LOGI

LG_OUT --> S_CS

S_CS --> BI1

S_RISK --> PY2

RK4 --> CS1

RK5 --> BI1

BI4 --> RK1

SA_OUT --> BI1

PY_OUT --> BI1

LG_OUT --> BI1

CS_OUT --> BI1

Also earlier we have "PY4 --> PY2" already captured.

Also "LG5 --> LG3" captured.

Also "BI4 --> BI5 --> BI4" captured.

Also "RK4 --> RK5 --> RK2": we have RK4->RK5, RK5->RK2 (need edge RK5->RK2). Already have RK5->RK_OUT, but also RK5->RK2 as per loop. So add edge RK5 -> RK2.

Also "CS3 --> CS5 --> CS1": we have CS3->CS5, CS5->CS1 (add edge CS5->CS1). Already have CS5->CS_OUT, but also CS5->CS1.

Also "BI4 --> BI5 --> BI4" we have both edges.

Now also "PY4 --> PY2" already.

Now also "BI4 --> BI5 --> BI4" we have both.

Now also "RK4 --> RK5 --> RK2" we have both.

Now also "CS3 --> CS5 --> CS1" we have both.

Now also "S_SALES --> PY1" we have.

Now also "PY3 --> S_LOGI" we have.

Now also "LG_OUT --> S_CS" we have.

Now also "S_CS --> BI1" we have.

Now also "S_RISK --> PY2" we have.

Now also "RK4 --> CS1" we have.

Now also "RK5 --> BI1" we have.

Now also "BI4 --> RK1" we have.

Now also "SA_OUT --> BI1" we have.

Now also "PY_OUT --> BI1" we have.

Now also "LG_OUT --> BI1" we have.

Now also "CS_OUT --> BI1" we have.

Now also "BI5 --> BI_OUT" we have.

Now also "BI6 --> BI_OUT" we have.

Now also "BI5 --> BI_OUT" already.

Now also "BI6 --> BI_OUT" already.

Now also "BI5 --> BI_OUT" duplicate? fine.

Now also "BI5 --> BI_OUT" we have.

Now also "BI6 --> BI_OUT" we have.

Now also "BI5 --> BI_OUT" done.

Now also "BI6 --> BI_OUT" done.

Now also "BI5 --> BI_OUT" done.

Now also "BI6 --> BI_OUT" done.

Now also "BI5 --> BI_OUT" done.

Ok.

Now also "BI5 --> BI_OUT" is edge.

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT" already.

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

Ok.

Now also "BI5 --> BI_OUT" done.

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

Stop.

Now also "BI5 --> BI_OUT" is fine.

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

Ok.

Now also "BI5 --> BI_OUT".

Now also "BI6 --> BI_OUT".

Now also "BI5 --> BI_OUT".

