We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (empty list?), summary.

We need to extract all nodes (including START, END, and all labeled nodes). Determine shape based on syntax: [] = rect, {} = diamond, () = circle, (()) = double_circle, [[]] = double_rect, >> = subroutine. In the diagram, nodes are defined like START([Start]) => shape rect. HUB{"업무 도메인 라우팅"} => {} diamond. Others: SA1["리드 수집"] => rect. SA3{"성사?"} => diamond. etc.

Subgraphs: each subgraph has an id and title. For example: subgraph S_SALES["SALES"] => id "S_SALES", title "SALES". Inside there are nested subgraphs: subgraph S_SALES_PIPE["Sales-Pipe"] => id "S_SALES_PIPE", title "Sales-Pipe". Similarly for others.

We need to list all subgraphs (including nested). Probably include all subgraph definitions.

Edges: need to capture all connections. Edge syntax: -->, --, -- "label" -->? Actually they use "-->" for directed edges, and "-- Yes -->" for decision branches with label. The schema expects "type": "-->", label maybe null or string. For edges with label, we set label to the label string (e.g., "Yes", "No", "주문", etc). For edges without label, label null.

Edge type: they only have "-->" direction. For edges like "SA3 -- Yes --> SA4", source SA3, target SA4, label "Yes". For "HUB -- "주문" --> S_SALES", label "주문". For "PY4 --> PY2" (loop) label null.

We must also include edges from subgraph to node? In Mermaid, "S_SALES --> PY1" means subgraph node? Actually "S_SALES" is a subgraph identifier, can be used as a node for linking. So treat subgraph as a node in edges. So edges can have source or target being subgraph id.

Thus nodes list should include all node ids (including START, END, HUB, SA1, SA2, SA3, SA4, SA_OUT, etc). Subgraphs are separate list.

We need to ensure each node entry includes "subgraphs": [] (maybe list of subgraph ids it belongs to?). The schema includes subgraphs field but we can leave empty list for each node (since not required). We'll set empty.

Decisions: maybe list of decision nodes? But schema says "decisions": [] . Could be left empty.

Summary: natural_language brief description, entry_nodes ["START"], exit_nodes ["END"].

Now compile nodes.

List all node definitions:

START([Start]) => id "START", label "Start", shape rect.

HUB{"업무 도메인 라우팅"} => id "HUB", label "업무 도메인 라우팅", shape diamond.

SA1["리드 수집"] => id "SA1", label "리드 수집", shape rect.

SA2["기회 생성"] => id "SA2", label "기회 생성", shape rect.

SA3{"성사?"} => id "SA3", label "성사?", shape diamond.

SA4["주문 생성"] => id "SA4", label "주문 생성", shape rect.

SA5["후속캠페인"] => id "SA5", label "후속캠페인", shape rect.

SA_OUT["주문 완료"] => id "SA_OUT", label "주문 완료", shape rect.

PY1["결제요청"] => id "PY1", label "결제요청", shape rect.

PY2{"승인?"} => id "PY2", label "승인?", shape diamond.

PY3["정산 예정"] => id "PY3", label "정산 예정", shape rect.

PY4["재시도/대체수단"] => id "PY4", label "재시도/대체수단", shape rect.

PY_OUT["정산 라인"] => id "PY_OUT", label "정산 라인", shape rect.

LG1["피킹"] => id "LG1", label "피킹", shape rect.

LG2["패킹"] => id "LG2", label "패킹", shape rect.

LG3["출고"] => id "LG3", label "출고", shape rect.

LG4{"지연?"} => id "LG4", label "지연?", shape diamond.

LG5["경로 재계획"] => id "LG5", label "경로 재계획", shape rect.

LG6["배송 진행"] => id "LG6", label "배송 진행", shape rect.

LG_OUT["배송 추적"] => id "LG_OUT", label "배송 추적", shape rect.

CS1["티켓 접수"] => id "CS1", label "티켓 접수", shape rect.

CS2{"우선순위?"} => id "CS2", label "우선순위?", shape diamond.

CS3["전담 처리"] => id "CS3", label "전담 처리", shape rect.

CS4["일반 처리"] => id "CS4", label "일반 처리", shape rect.

CS5["해결/콜백"] => id "CS5", label "해결/콜백", shape rect.

CS_OUT["CS 종료"] => id "CS_OUT", label "CS 종료", shape rect.

RK1["피쳐수집"] => id "RK1", label "피쳐수집", shape rect.

RK2["모델스코어링"] => id "RK2", label "모델스코어링", shape rect.

RK3{"위험>임계?"} => id "RK3", label "위험>임계?", shape diamond.

RK4["차단/리뷰"] => id "RK4", label "차단/리뷰", shape rect.

RK5["정책업데이트"] => id "RK5", label "정책업데이트", shape rect.

RK6["승인 통과"] => id "RK6", label "승인 통과", shape rect.

RK_OUT["정책 반영"] => id "RK_OUT", label "정책 반영", shape rect.

BI1["데이터 집계"] => id "BI1", label "데이터 집계", shape rect.

BI2["대시보드 갱신"] => id "BI2", label "대시보드 갱신", shape rect.

BI3{"이상징후?"} => id "BI3", label "이상징후?", shape diamond.

BI4["알림/깃발"] => id "BI4", label "알림/깃발", shape rect.

BI5["원인분석"] => id "BI5", label "원인분석", shape rect.

BI6["정상 리포트"] => id "BI6", label "정상 리포트", shape rect.

BI_OUT["분석결과"] => id "BI_OUT", label "분석결과", shape rect.

END([End]) => id "END", label "End", shape rect.

Also maybe nodes for subgraph ids? Not needed as nodes, but edges reference subgraph ids like S_SALES, S_PAY, etc. Those are subgraphs, not nodes. However edges like "S_SALES --> PY1" treat subgraph as source. In JSON edges, source can be subgraph id. That's fine.

Now edges list. Let's enumerate all connections in order.

1. START --> HUB (no label). Edge: source "START", target "HUB", type "-->", label null.

2. HUB --> S_SALES with label "주문". Edge: source "HUB", target "S_SALES", label "주문".

3. HUB --> S_PAY label "결제".

4. HUB --> S_LOGI label "물류".

5. HUB --> S_CS label "CS".

6. HUB --> S_RISK label "리스크".

7. HUB --> S_BI label "리포팅".

Now within subgraphs:

Sales subgraph:

SA1 --> SA2 (no label)

SA2 --> SA3 (no label)

SA3 -- Yes --> SA4 (label "Yes")

SA3 -- No --> SA5 (label "No")

SA5 --> SA2 (no label)

SA4 --> SA_OUT (no label)

Now cross connections:

S_SALES --> PY1 (no label)

Now Payments subgraph:

PY1 --> PY2 (no label)

PY2 -- Yes --> PY3 (label "Yes")

PY2 -- No --> PY4 (label "No")

PY4 --> PY2 (loop) (no label) (also later duplicate but same)

PY3 --> PY_OUT (no label)

Cross: PY3 --> S_LOGI (no label)

PY_OUT --> BI1 (no label)

Now Logistics subgraph:

LG1 --> LG2

LG2 --> LG3

LG3 --> LG4

LG4 -- Yes --> LG5 (label "Yes")

LG4 -- No --> LG6 (label "No")

LG5 --> LG3 (no label) (also loop defined later)

LG6 --> LG_OUT (no label)

Cross: LG_OUT --> S_CS (no label)

LG_OUT --> BI1 (no label) (also later duplicate)

Now Customer Support subgraph:

CS1 --> CS2

CS2 -- High --> CS3 (label "High")

CS2 -- Normal --> CS4 (label "Normal")

CS3 --> CS5

CS4 --> CS5

CS5 --> CS_OUT

Cross: S_CS --> BI1 (no label)

CS_OUT --> BI1 (no label)

CS3 --> CS5 --> CS1 loop: Actually they have "CS3 --> CS5 --> CS1". That's two edges: CS3 --> CS5 (already defined) and CS5 --> CS1 (new). So add edge CS5 --> CS1 (no label).

Now Risk subgraph:

RK1 --> RK2

RK2 --> RK3

RK3 -- Yes --> RK4 (label "Yes")

RK3 -- No --> RK6 (label "No")

RK4 --> RK5

RK5 --> RK_OUT

Cross: S_RISK --> PY2 (no label)

RK4 --> CS1 (no label) (edge from RK4 to CS1)

RK5 --> BI1 (no label) (already cross)

BI4 --> RK1 (no label) (cross)

Now BI subgraph:

BI1 --> BI2

BI2 --> BI3

BI3 -- Yes --> BI4 (label "Yes")

BI3 -- No --> BI6 (label "No")

BI4 --> BI5

BI5 --> BI_OUT

BI6 --> BI_OUT

Cross: BI4 --> BI5 --> BI4 loop: Actually they have "BI4 --> BI5 --> BI4". That's edges: BI4 --> BI5 (already) and BI5 --> BI4 (new). So add edge BI5 --> BI4 (no label).

BI5 --> BI1 (cross) (already cross from earlier: SA_OUT --> BI1, PY_OUT --> BI1, LG_OUT --> BI1, CS_OUT --> BI1, RK5 --> BI1, etc). So add edge BI5 --> BI1 (no label).

Also earlier cross: S_CS --> BI1 (already). S_RISK --> PY2 (already). S_SALES --> PY1 (already). PY_OUT --> BI1 (already). LG_OUT --> BI1 (already). CS_OUT --> BI1 (already). RK5 --> BI1 (already). SA_OUT --> BI1 (need edge SA_OUT --> BI1). Add that.

Now also cross: BI4 --> RK1 (already). BI4 --> BI5 (already). BI4 --> BI5 --> BI4 loop we added.

Now also cross: RK4 --> RK5 --> RK2 loop: edges: RK4 --> RK5 (already), RK5 --> RK2 (new). So add edge RK5 --> RK2 (no label).

Now also cross: CS3 --> CS5 --> CS1 loop we added CS5 --> CS1.

Now also cross: PY4 --> PY2 (already added earlier as loop). Already have.

Now also cross: LG5 --> LG3 (already added). Already.

Now also cross: BI4 --> BI5 --> BI4 loop we added.

Now also cross: RK4 --> RK5 --> RK2 loop we added.

Now also cross: CS3 --> CS5 --> CS1 loop we added.

Now also cross: SA5 --> SA2 already.

Now also cross: SA_OUT --> BI1 (add edge).

Now also cross: BI4 --> RK1 (already added).

Now also cross: RK4 --> CS1 (added).

Now also cross: S_RISK --> PY2 (added).

Now also cross: S_CS --> BI1 (added).

Now also cross: S_LOGI? Already have PY3 --> S_LOGI.

Now also cross: S_LOGI? maybe also something else? Not.

Now also cross: S_BI? Not needed.

Now also cross: S_SALES? Already.

Now also cross: S_PAY? Not.

Now also cross: S_LOGI? Already.

Now also cross: S_RISK? Already.

Now also cross: S_CS? Already.

Now also cross: S_BI? Not.

Now also cross: BI4 --> RK1 (added).

Now also cross: BI4 --> BI5 (already). Good.

Now also cross: BI5 --> BI4 (added). Good.

Now also cross: BI5 --> BI1 (added). Good.

Now also cross: RK5 --> RK2 (added). Good.

Now also cross: RK5 --> BI1 (added). Good.

Now also cross: SA_OUT --> BI1 (added). Good.

Now also cross: PY_OUT --> BI1 (added). Good.

Now also cross: LG_OUT --> BI1 (added). Good.

Now