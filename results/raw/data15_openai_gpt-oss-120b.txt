We need to parse the Mermaid flowchart and output JSON with given schema. Must include nodes, edges, subgraphs, decisions (empty?), summary.

We need to extract all nodes: each node defined with label syntax: e.g., START([Start]) => shape rect? Actually [] is rect. So shape "rect". ID is the identifier before parentheses: START. Label is "Start". Similarly END([End]) shape rect.

Other nodes: ENTRY["요청 수신"] => shape rect (since []), id ENTRY, label "요청 수신". ROUTER{"도메인/경로 라우팅"} => shape diamond ({}). id ROUTER, label "도메인/경로 라우팅". etc.

Subgraphs: each subgraph S_AUTH["AUTH (인증/권한)"] => id S_AUTH, title "AUTH (인증/권한)". Similarly S_IDP, S_ACL, S_TENANT, S_TMAP, S_TPLAN, S_BILL, S_CHARGE, S_AR, S_FLAG, S_PIPE, S_ING, S_PROC, S_STORE, S_COMP, S_IR.

We need to list subgraphs array with id and title.

Nodes also include those inside subgraphs. All nodes have shape based on brackets.

We also have decision nodes: those with {} shape are diamonds. In schema there is "decisions": [] maybe we need to list decision nodes? The schema includes decisions array, but not defined. Probably we can leave empty or include decision node ids. The instruction says "decisions": [] . So we can keep empty.

Edges: need to list each connection. Edge type is "-->" as per example. Some edges have labels like "No", "Yes". In Mermaid syntax, they are like A4 -- No --> A5. So label "No". So edge object includes label maybe string. If no label, null.

We must capture all edges.

Let's enumerate nodes:

List all node definitions:

START, END, ENTRY, ROUTER, A1, A2, A3, A4, A5, A_OK, T1, T2, T_ERR, T3, T4, T_LIM, T_OK, B1, B2, B3, B4, B5, B6, B7, B8, B_AR_OK, B_OUT, B_OUT? Actually B_OUT is defined as B_OUT["Billing OK"]? Wait B_OUT is defined as B_OUT["Billing OK"]? Actually in subgraph S_BILL, after B_AR_OK --> B_OUT["Billing OK"] . So B_OUT node label "Billing OK". shape rect.

Also B_OUT appears later: B_OUT --> IR1.

F1, F2, F3, F4, F_OUT.

P1, P2, P3, P4, P5, P6, P7, P8, P9, P10, P_OUT? Actually P_OUT["Pipe OK"] defined but not connected? It's defined as P_OUT["Pipe OK"] but not used elsewhere. So node P_OUT.

C1, C2, C3, C4, C5, C_OK.

IR1, IR2, IR3, IR4, IR_OK.

Also maybe B_AR_OK node defined as B_AR_OK["정상"] shape rect.

Also B_OUT defined.

Also B5 node label "재시도/대체수단". shape rect.

Also B7 node label "미수금 체크". shape rect.

Also B8 node label "연체?" shape diamond.

Also B_AR_OK shape rect.

Also B_OUT shape rect.

Also B6 shape rect.

Also B5 shape rect.

Also B3 shape rect.

Also B4 diamond.

Also B2 diamond.

Also B1 rect.

Also B7 rect.

Also B8 diamond.

Also B_AR_OK rect.

Also B_OUT rect.

Also B_OUT is used as source to IR1.

Also F_OUT node label "Flag OK". shape rect.

Also P_OUT node label "Pipe OK". shape rect.

Also C_OK node label "Compliant". shape rect.

Also IR_OK node label "정상". shape rect.

Also A_OK node label "Auth OK". shape rect.

Also T_OK node label "Tenant OK". shape rect.

Also T_ERR node label "404 테넌트 없음". shape rect.

Also T_LIM node label "429 쿼터 초과". shape rect.

Also B_OUT node label "Billing OK". shape rect.

Also B_AR_OK node label "정상". shape rect.

Also B_OUT appears also as node.

Also B_OUT is used as source to IR1.

Also B_OUT is defined as B_OUT["Billing OK"].

Also B_OUT is also used as target? Not.

Also B_OUT is not inside any subgraph? It's inside S_BILL after B_AR_OK --> B_OUT["Billing OK"].

Now edges: Let's list all edges in order.

From top:

START --> ENTRY (no label)

ENTRY --> ROUTER

ROUTER --> S_AUTH (subgraph as target). Edge type "-->" label null.

Within S_AUTH:

A1 --> A2

A2 --> A3

A3 --> A4

A4 -- No --> A5

A4 -- Yes --> A_OK

A_OK --> S_TENANT (outside subgraph). Edge.

Also A5 --> END

Now S_TENANT internal:

T1 --> T2

T2 -- No --> T_ERR

T2 -- Yes --> T3

T3 --> T4

T4 -- Yes --> T_LIM

T4 -- No --> T_OK

Also T_ERR --> END

T_LIM --> END

T_OK --> ??? Not used further.

S_TENANT --> S_FLAG (edge)

Now S_FLAG internal:

F1 --> F2

F2 -- Yes --> F3

F2 -- No --> F4

F3 --> F_OUT

F4 --> F_OUT

F_OUT --> P1

Now S_PIPE internal:

P1 --> P2

P2 --> P3

P3 -- Yes --> P4

P4 --> P2

P3 -- No --> P5

P5 --> P6

P6 --> P7

P7 --> P8

P8 --> P9

P9 --> P10

P_OUT? Not connected.

S_PIPE --> S_COMP

Now S_COMP internal:

C1 --> C2

C2 --> C3

C3 -- Yes --> C4

C3 -- No --> C_OK

C4 --> C5

C5 --> C1

C_OK --> B1

Now S_BILL internal:

B1 --> B2

B2 -- Yes --> B3

B2 -- No --> B1

B3 --> B4

B4 -- No --> B5

B5 --> B3

B4 -- Yes --> B6

B6 --> B7

B7 --> B8

B8 -- Yes --> B9

B9 --> B7

B8 -- No --> B_AR_OK

B_AR_OK --> B_OUT

B_OUT --> IR1

Also B6 --> B7 already.

Also B7 --> B8 already.

Also B7 --> B8 --> B7 loop.

Now S_IR internal:

IR1 --> IR2

IR2 -- Yes --> IR3

IR3 --> IR4

IR4 --> IR_OK

IR2 -- No --> IR_OK

IR_OK --> END

Also C4 --> IR3 (edge from C4 to IR3)

Also B_OUT --> IR1 already captured.

Also F_OUT --> P1 captured.

Also C_OK --> B1 captured.

Also A5 --> END captured.

Also T_ERR --> END captured.

Also T_LIM --> END captured.

Also B_OUT --> IR1 captured.

Also B_OUT is also target of B_AR_OK.

Now also there is edge S_TENANT --> S_FLAG captured earlier.

Also S_FLAG --> S_PIPE captured.

Also S_PIPE --> S_COMP captured.

Also S_COMP --> S_BILL captured.

Also S_BILL --> S_IR captured.

Now also there is edge A_OK --> S_TENANT captured.

Now also there is edge ROUTER --> S_AUTH captured.

Now also there is edge S_AUTH? Not other.

Now also there is edge S_TENANT? Already.

Now also there is edge S_BILL? Already.

Now also there is edge S_IR? Not.

Now also there is edge S_COMP? Already.

Now also there is edge S_FLAG? Already.

Now also there is edge S_PIPE? Already.

Now also there is edge S_TENANT? Already.

Now also there is edge S_AUTH? Already.

Now also there is edge S_TENANT? Already.

Now also there is edge S_BILL? Already.

Now also there is edge S_IR? Already.

Now also there is edge S_COMP? Already.

Now also there is edge S_FLAG? Already.

Now also there is edge S_PIPE? Already.

Now also there is edge S_TENANT? Already.

Now also there is edge S_AUTH? Already.

Now also there is edge S_TENANT? Already.

Now also there is edge S_TENANT? Already.

Ok.

Now we need to list subgraphs: each subgraph id and title.

List:

S_AUTH title "AUTH (인증/권한)"

S_IDP title "IDP 연동"

S_ACL title "권한/스코프"

S_TENANT title "TENANT ROUTER"

S_TMAP title "테넌트 매핑"

S_TPLAN title "플랜/쿼터"

S_BILL title "BILLING"

S_CHARGE title "과금흐름"

S_AR title "정산/미수"

S_FLAG title "FEATURE FLAG & RELEASE"

S_PIPE title "DATA PIPELINE"

S_ING title "수집"

S_PROC title "처리"

S_STORE title "저장"

S_COMP title "COMPLIANCE & AUDIT"

S_IR title "INCIDENT RESPONSE"

Now nodes: need to include all nodes with id, label, shape, subgraphs: [] (maybe list of subgraph ids they belong to? The schema says subgraphs: [] but we can leave empty for each node.

We'll set subgraphs empty.

Now edges: need to include source, target, type "-->", label (null or string). For edges with label "Yes"/"No". Also edges like B5 --> B3 have no label.

Now summary: natural_language: brief description. entry_nodes: ["START"]; exit_nodes: ["END"].

Now warnings: empty.

Now ok: true.

Now decisions: empty.

Now produce JSON.

We must ensure proper JSON formatting, arrays, objects.

Let's compile nodes list.

I'll enumerate nodes with id and label and shape.

- START: label "Start", shape "rect"
- ENTRY: "요청 수신", rect
- ROUTER: "도메인/경로 라우팅", diamond
- END: "End", rect
- A1: "OIDC 로그인", rect
- A2: "토큰 발급", rect
- A3: "스코프 파싱", rect
- A4: "권한 충족?", diamond
- A5: "403 반환", rect
- A_OK: "Auth OK", rect
- T1: "도메인→테넌트ID", rect
- T2: "존재?", diamond
- T_ERR: "404 테넌트 없음", rect
- T3: "플랜 조회", rect
- T4: "쿼터 초과?", diamond
- T_LIM: "429 쿼터 초과", rect
- T_OK: "Tenant OK", rect
- F1: "플래그 평가", rect
- F2: "활성?", diamond
- F3: "신규 경로", rect
- F4: "기존 경로", rect
- F_OUT: "Flag OK", rect
- P1: "API 이벤트", rect
- P2: "큐 적재", rect
- P3: "지연>2s?", diamond
- P4: "Backpressure", rect
- P5: "정제", rect
- P6: "파싱/정규화", rect
- P7: "특징 생성", rect
- P8: "검증", rect
- P9: "Hot KV", circle? Actually syntax P9[("Hot KV")] uses double parentheses? It's [("Hot KV")] meaning parentheses inside brackets? In Mermaid, [("text")] is a circle? Actually (()) is double_circle, () is circle. [()] is rectangle with rounded? Not sure. The shape mapping: [] = rect, () = circle, (()) = double_circle, [[]] = double_rect, >> = subroutine. Here we have P9[("Hot KV")] which is bracket with parentheses inside, but outer is [] so shape rect. So label "Hot KV". shape rect.
- P10[("Cold Lake")] similarly rect, label "Cold Lake".
- P_OUT: "Pipe OK", rect
- C1: "PII 스캔", rect
- C2: "마스킹/토큰화", rect
- C3: "위반?", diamond
- C4: "차단/알림", rect
- C5: "정책 업데이트", rect
- C_OK: "Compliant", rect
- B1: "사용량 누계", rect
- B2: "청구 시점?", diamond
- B3: "결제 시도", rect
- B4: "승인?", diamond
- B5: "재시도/대체수단", rect
- B6: "청구 완료", rect
- B7: "미수금 체크", rect
- B8: "연체?", diamond
- B9: "알림/제한", rect
- B_AR_OK: "정상", rect
- B_OUT: "Billing OK", rect
- IR1: "오류율 모니터", rect
- IR2: "임계 초과?", diamond
- IR3: "온콜 호출",